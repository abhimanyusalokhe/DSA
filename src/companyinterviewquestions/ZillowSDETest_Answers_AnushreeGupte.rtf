{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red42\green0\blue255;
\red0\green0\blue192;}
\paperw16840\paperh23820\margl1440\margr1440\vieww13920\viewh12040\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs22 \cf0 \
\
	\cf2 /*\
	 * Q1) Convert string to long\cf0 \
\pard\pardeftab720
\cf2 	 * Function - stringToLong\cf0 \
\cf2 	 * Description - Takes a string representation of long and returns long type\cf0 \
\cf2 	 * Parameters - String - containing the number to convert\cf0 \
\cf2 	 * Returns - long representation of the number\cf0 \
\cf2 	 * Exception - NumberFormatException if invalid string passed\cf0 \
\cf2 	 * 			valid - "123", "-123", "-123123", "+123"\cf0 \
\cf2 	 * 			invalid - "--123","-", "\ul asdfa\ulnone "\cf0 \
\cf2 	 */\cf0 \
	\cf3 public\cf0  \cf3 long\cf0  stringToLong(String s) \{\
		\cf2 // Check if string contains valid long number format..\cf0 \
		\cf3 if\cf0 (!Pattern.matches(\cf4 "^[-+]?[0-9]+"\cf0 , s)) \cf3 throw\cf0  \cf3 new\cf0  NumberFormatException();\
		\
		\cf3 char\cf0  current;\
		\cf3 long\cf0  num = 0l;\
		\cf2 // Iterate through each character of input string\cf0 \
		\cf3 for\cf0 (\cf3 int\cf0  i=0 ; i<s.length() ; i++)\{\
			current = s.charAt(i);\
			\
			\cf2 // if character is '-' , continue no need to convert\cf0 \
			\cf3 if\cf0 (current == \cf4 '-'\cf0 ) \cf3 continue\cf0 ;\
			\
			\cf2 // calculate long representation\cf0 \
			num = num * 10 + (current-\cf4 '0'\cf0 );\
			\cf3 if\cf0 (num < 0)\
				\cf3 throw\cf0  \cf3 new\cf0  NumberFormatException();\
		\}\
		\
		\cf3 if\cf0 (s.charAt(0)==\cf4 '-'\cf0 )\{\
			\cf3 return\cf0  num * -1;\
		\}\
		\cf3 return\cf0  num;\
	\}\
\
\
	\cf2 /*\
	 * Q2) Trinary tree insert and delete operations\cf0 \
\cf2 	 * Function : insert\cf0 \
\cf2 	 * Description: Inserts a value in \ul tri\ulnone -\ul nary\ulnone  search tree\cf0 \
\cf2 	 * Parameters: Node - Root node of the tree\cf0 \
\cf2 	 * 				value - Value to insert in tree\cf0 \
\cf2 	 * Returns:	Node - Root node of tree\cf0 \
\cf2 	 */\cf0 \
	\cf3 public\cf0  Node insert(Node node, \cf3 int\cf0  data)\{\
		\cf3 if\cf0 (node==\cf3 null\cf0 )\{\
			\cf2 // Create new node and assign data\cf0 \
			node=\cf3 new\cf0  Node(data);\
		\}\cf3 else\cf0 \{\
			\cf2 // If smaller than current node value.. go to left\cf0 \
			\cf3 if\cf0 (data<node.\cf5 value\cf0 )\{\
				node.\cf5 left\cf0 =insert(node.\cf5 left\cf0 ,data);\
			\}\cf2 // If equal to current node value.. go to middle\cf0 \
			\cf3 else\cf0  \cf3 if\cf0 (data==node.\cf5 value\cf0 )\{\
				node.\cf5 middle\cf0 =insert(node.\cf5 middle\cf0 ,data);\
			\}\cf2 // If greater than current node value.. go to right\cf0 \
			\cf3 else\cf0  \cf3 if\cf0 (data>node.\cf5 value\cf0 )\{\
				node.\cf5 right\cf0 =insert(node.\cf5 right\cf0 ,data);\
			\}\
		\}\
		\cf3 return\cf0  node;\
	\}\
	\
	\cf2 /*\cf0 \
\cf2 	 * Function : delete\cf0 \
\cf2 	 * Description: Deletes a node from \ul tri\ulnone -\ul nary\ulnone  search tree\cf0 \
\cf2 	 * Parameters: Node - Root node of the tree\cf0 \
\cf2 	 * 				value - Value to delete from tree\cf0 \
\cf2 	 * Returns:	Node - Root node of tree\cf0 \
\cf2 	 */\cf0 \
	\cf3 public\cf0  Node delete(Node node, \cf3 int\cf0  value)\{\
		\cf2 // if node value is greater than value to \ul delte\ulnone .. go left\cf0 \
		\cf3 if\cf0  (node.\cf5 value\cf0  > value)\{\
			node.\cf5 left\cf0  = delete(node.\cf5 left\cf0 , value);\
		\}\cf2 // if node value is lesser than value to \ul delte\ulnone .. go right\cf0 \
		\cf3 else\cf0  \cf3 if\cf0 (node.\cf5 value\cf0  < value)\{\
			node.\cf5 right\cf0  = delete(node.\cf5 right\cf0 , value);\
		\}\cf3 else\cf0 \{\
			\cf2 // if found.. check if node has middle and traverse to middle element if it does\cf0 \
			\cf3 if\cf0  (node.\cf5 middle\cf0  != \cf3 null\cf0 )\{\
				node.\cf5 middle\cf0  = delete(node.\cf5 middle\cf0 , value);\
			\}\cf2 // if no middle element check if it has right child\cf0 \
			\cf3 else\cf0  \cf3 if\cf0 (node.\cf5 right\cf0  != \cf3 null\cf0 )\{\
				\cf3 int\cf0  min = minimum(node.\cf5 right\cf0 ).\cf5 value\cf0 ;\
				node.\cf5 value\cf0  = min;\
				node.\cf5 right\cf0  = delete(node.\cf5 right\cf0 , min);\
			\}\cf2 // if no right child replace node with left node\cf0 \
			\cf3 else\cf0 \{\
				node = node.\cf5 left\cf0 ;\
			\}\
      	\}\
      	\cf3 return\cf0  node;\
  	\}\
\
	\cf2 // Private function to find minimum value node in tree\cf0 \
	\cf3 private\cf0  Node minimum(Node node)\{\
		\cf3 if\cf0 (node != \cf3 null\cf0 )\{\
			\cf3 while\cf0  (node.\cf5 left\cf0  != \cf3 null\cf0 )\{\
				\cf3 return\cf0  minimum(node.\cf5 left\cf0 );\
			\}\
		\}\
	    \cf3 return\cf0  node;\
	\}}